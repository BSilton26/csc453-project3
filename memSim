#!/usr/bin/env python3
import argparse
from collections import OrderedDict  # required since dictionaries are only ordered starting in Python 3.7

parser = argparse.ArgumentParser(
    prog='memSim',
    description='A virtual memory simulator which translates virtual memory addresses to physical memory addresses.',
    usage='%(prog)s [-h] filename FRAMES PRA')

parser.add_argument('filename')
parser.add_argument('frames',
                    metavar='FRAMES',
                    nargs='?',
                    type=int,
                    choices=range(1, 257),
                    default=256,
                    help='the number of frames in memory, 1 through 256 inclusive (default: %(default)s)')
parser.add_argument('pra',
                    metavar='PRA',
                    nargs='?',
                    choices=['FIFO', 'LRU', 'OPT'],
                    default='FIFO',
                    help='the page replacement algorithm to use, one of %(choices)s   (default: %(default)s)')


def main():
    args = parser.parse_args()
    filename = args.filename
    num_frames = args.frames
    page_replacement_alg = args.pra

    print(f"filename={filename}, frames={num_frames}, pra={page_replacement_alg}")

    addresses = []
    # Load all addresses into our array
    with open(filename) as file:
        for line in file:
            addresses.append(int(line.strip()))  # Make sure that we strip off whitespace

    print(f"Read addresses: {addresses}")

    tlb = TLB()
    page_table = PageTable()
    memory = Memory(num_frames, page_replacement_alg)
    backing_store = BackingStore("BACKING_STORE.bin")

    for address in addresses:
        # Pages/frames are always 256 bytes => 8 bits for offset
        # 256 pages in virtual memory => 8 bits for page number
        # So, 16 bits for virtual addresses
        page_num = address >> 8  # upper 8 bits
        offset = address & 255  # lower 8 bits
        print(f"addr: {address:>016b}")
        print(f"page_num: {page_num:>08b}, offset: {offset:>08b}")
        frame_num = -1
        frame_num = tlb.lookup(page_num)
        if frame_num >= 0:  # TLB hit
            frame = memory.lookup(frame_num)
            byte = frame.data[offset]
            # TODO: print output
            continue
        # TLB miss, lookup in page table
        frame_num = page_table.lookup(page_num)
        if frame_num >= 0:  # Page table hit
            tlb.update(page_num, frame_num)
            frame = memory.lookup(frame_num)
            byte = frame.data[offset]
            # TODO: print output
            continue
        # Page table missed so poll backing store, then update memory, page table, TLB
        block = backing_store.get_block(page_num)
        frame_num = memory.put(block)
        page_table.update(page_num, frame_num)
        tlb.update(page_num, frame_num)
    # TODO: print overall stats


class TLB:
    def __init__(self):
        self.page_to_frame = OrderedDict([(i, -1) for i in range(-16, 0)])  # initialize dict with all negative nums
        self.hits = 0
        self.misses = 0

    def lookup(self, page_num):
        assert page_num >= 0
        try:
            frame_num = self.page_to_frame[page_num]
            self.hits += 1
            return frame_num
        except KeyError:  # TLB miss
            self.misses += 1
            return -1

    def update(self, page_num, frame_num):
        self.page_to_frame.popitem(last=False)  # pop items from dict in FIFO order
        self.page_to_frame[page_num] = frame_num
        assert len(self.page_to_frame) == 16


class PageTable:
    def __init__(self):
        self.entries = 256 * [(-1, False)]  # A list of 256 entries: (pg#, valid)
        self.lookups = 0
        self.faults = 0

    def lookup(self, page_num):
        entry = self.entries[page_num]
        if self.is_valid(entry):
            self.lookups += 1
            return self.get_frame(entry)
        self.faults += 1
        return -1

    def is_valid(self, entry):
        """Simple wrapper for readability. Returns valid bool (second element) of entry tuple."""
        return entry[1]

    def get_frame(self, entry):
        """Simple wrapper for readability. Returns frame (first element) of entry tuple."""
        return entry[0]

    def update(self, page_num, frame_num):
        self.entries[page_num] = (frame_num, True)


class Frame:
    def __init__(self, data):
        self.data = data
        self.last_accessed = 0
        self.age = 0

    def read(self):
        self.last_accessed = 0
        return self.data

    def increment_time(self):
        self.age += 1
        self.last_accessed += 1


class PRA:
    def __init__(self, pages, alg="FIFO"):
        self.pages = pages
        self.alg = alg

    def next_place(self, frames):
        if self.alg is "LRU":
            # TODO: implement LRU
            return None
        if self.alg is "OPT":
            # TODO: implement OPT
            return None
        return self.fifo([frame.age for frame in frames])  # Default to FIFO

    @staticmethod
    def fifo(frame_ages):
        max_age = max(frame_ages)
        index = frame_ages.index(max_age)
        return index


class Memory:
    def __init__(self, num_frames, page_replacement_algorithm: PRA):
        self.frames = num_frames * [Frame(None)]  # List of size `num_frames` Frames initialized with None data
        self.pra = page_replacement_algorithm

    def lookup(self, frame_num):
        # Increment all frames
        for frame in self.frames:
            frame.increment_time()
        data = self.frames[frame_num].read()
        return data

    def put(self, page_num, frame):
        """Puts an array of 256 ints into memory at a frame determined by self.page_replacement_algorithm.

        :returns: the frame number of the newly loaded array
        :rtype: int
        """
        new_frame_num = self.pra.next_place(self.frames)
        self.frames[new_frame_num] = frame
        return new_frame_num


class BackingStore:
    # TODO: write BackingStore
    pass


if __name__ == "__main__":
    main()
